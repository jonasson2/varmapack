// Testvarmapack_sim  Test correctness of varmapack_sim.c
//
//   DESCRIPTION
//     Testvarmapack_sim carries out several different tests of the function varmapack_sim.
//     All the tests are carried out for the 8 first testcases from varmapack_testcase.c.
//     All tests compare theoretical statistics of the models with data statistics
//     of simulated series. The tests are the following.
//
//     1) The mean of 1000 simulated series of length 200 is compared with the mu
//        used in the simulation.
//
//     2) A single series of length 20000 is simulated and the variance of the
//        data as well as covariance at lag 1 is compared with theoretical values.
//
//     3) 20000 series of length n = 3 + max(p,q) are constructed and the whole
//        series covariance of these observations (which correspond to having 
//        20000 observations of an n*r variate normal variable) are compared
//        with the theoretical whole series covariance matrix.
//
//     4) 20000 series of length n = 2 * max(p,q) are constructed. The resulting
//        series are each split into two halfs thus giving two sets of 20000 
//        observations of length max(p,q). The data covariance of these two 
//        sets is compared with the theoretical covariance. This should reveal
//        possible deficiency in the stated spinup-freem-ness of varmapack_sim.
//
//     5) One step ahead and two steps ahead predictions are constructed
//        starting from given values of X, and their 


//     varmapack_sim.
//     Testvarmapack_sim prints theoretical covariance, data covariance of simulated
//     series, and the max relative difference between the two, for 8 testcases.

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include "BlasGateway.h"
#include "varmapack.h"
#include "allocate.h"
#include "VarmaUtilities.h"
#include "VarmaMisc.h"
#include "Tests.h"
#include "randompack.h"
#include "debugprint.h"

static void expX(double A[], double B[], double X[], double mu[], double CC[],
                 double SS[], double Sig[], int p, int q, int r, int n,
                 double Ex1[], double Ex2[], double Vx1[]); // (forward)

int Testvarmapack_sim(char *code) { // code for example = "PF" for print, full,
  // "F" for no-print, full or "" for no-print, standard
  int i, p, q, r, n, M, n1, M1, icase, PRINT, FULL, OK;
  int h, n2, M2, ifail;
  char testname[12];
  double *X, *mu, *mu3, *mud, d1, d2, d3, d4, d5, d6, d7, d8, dmax;
  double *A, *B, *Sig, *X0, *CC, *SS, *X1, *X2, *XX, *SSd, *CCd, *CC21;
  double *eps, *Ex1, *Ex2, *Vx1;
  PRINT = strchr(code, 'P') != 0;
  FULL  = strchr(code, 'F') != 0;
  RandRng *rng = rand_create();
  rand_settype(PARKMILLER, rng);
  rand_setPMseed(42, rng);
  icase = 1;
  n1 = 20;
  M1 = 1000;
  n2 = 25000;
  M2 = 25000;
  // n1 = M1 = n2 = M2 = 50; // (used while debugging)
  ifail = 0;
  if (PRINT) { printf("\n  Test varmapack_sim"); fflush(0); }
  while (true) {
    dmax = 0;
    varmapack_testcase(0, 0, 0, testname, &p, &q, &r, icase, rng); // find dimensions
    prints(testname);
    if ((FULL && icase > 10) || (!FULL && icase > 8)) break;
    if (icase > 8) { // Full test
      n1 = 1000; M1 = 6000; n2 = 100000; M2 = 100000; 
    }
    if (r == 0) break; // named test cases exhausted
    allocate(A, r*r*p);
    allocate(B, r*r*q);
    allocate(Sig, r*r);
    allocate(mu, r);
    for (i=0; i<r; i++) mu[i] = i + 1;
    varmapack_testcase(A, B, Sig, testname, &p, &q, &r, icase, rng);
    h = max(p,q);
    //
    // COMPARE MEAN (WITH 1000 SERIES OF LENGTH 200):
    n = n1; 
    M = M1;
    allocate(X,r*n*M);
    allocate(mu3, r*n);
    allocate(mud, r);
    varmapack_sim(A, B, Sig, mu, p, q, r, n, M, 0, rng, X, 0, &OK); xAssert(OK);
    mean3(X, r, n, M, 3, mu3);
    meanmat("T", r, n, mu3, r, mud);
    d1 = relabsdiff(mu, mud, r);
    dmax = max(d1, dmax);
    freem(mud); freem(mu3); freem(X);
    //
    // START FROM SCRATCH; COMPARE DATA COVARIANCE WITH THEORETICAL:
    n = n2;
    M = M2;
    allocate(CC, 2*r*2*r);
    allocate(SS, 2*r*2*r);
    SCbuild(A, B, Sig, p, q, r, 2, CC, SS); // Theoretical cov. n=2
    allocate(X, r*n); // simulate a long single series
    varmapack_sim(A, B, Sig, 0, p, q, r, n, 1, 0, rng, X, 0, &OK); xAssert(OK);
    allocate(XX, (n-1)*r*2);
    allocate(SSd, 2*r*2*r);
    copytranspose(r, n-1, X, r, XX, n-1); // XX = [X(:,1:n-1)' X(:,2:n)']
    copytranspose(r, n-1, X+r, r, XX + (n-1)*r, n-1);
    cov("N", n-1, 2*r, XX, SSd);
    d2 = relabsdiff(SSd, SS, 2*r*2*r);
    dmax = max(d2, dmax);
    freem(SSd); freem(XX); freem(X);
    freem(SS); freem(CC);
    //
    n = h+3;
    allocate(X, r*n*M); // simulate several short series
    allocate(CC, r*n * r*n);
    allocate(SS, r*n * r*n);
    SCbuild(A, B, Sig, p, q, r, n, CC, SS); // Theoretical cov. 
    varmapack_sim(A, B, Sig, 0, p, q, r, n, M, 0, rng, X, 0, &OK); xAssert(OK);
    allocate(SSd, r*n * r*n);
    cov("T", r*n, M, X, SSd);
    d3 = relabsdiff(SSd, SS, n*r*n*r);
    dmax = max(d3, dmax);
    freem(SS); freem(CC);
    freem(SSd); freem(X);
    //
    // CHECK EPS, SERIES OF LENGTH 2*h; COMPARE CC WITH DATA COV(X,EPS):
    n = 2*h;
    allocate(X, r*n*M);
    allocate(eps, r*n*M);
    varmapack_sim(A, B, Sig, 0, p, q, r, n, M, 0, rng, X, eps, &OK); xAssert(OK);
    allocate(CC, r*h * r*h);
    allocate(SS, r*h * r*h);
    allocate(X1, M*r*h*2);
    allocate(X2, M*r*h*2);
    allocate(CCd, 2*r*h * 2*r*h);
    allocate(CC21, r*h * r*h);
    SCbuild(A, B, Sig, p, q, r, h, CC, SS); // Theoretical cov.
    copytranspose(r*h, M, X, r*n, X1, M); // X1 = [X(1:h,1:M)' eps(1:h,1:M)']
    copytranspose(r*h, M, eps, r*n, X1 + r*h*M, M);
    copytranspose(r*h, M, X + r*h, r*n, X2, M); // X2 = [X(h+1:,1:M)' eps(h+1:,1:M)']
    copytranspose(r*h, M, eps + r*h, r*n, X2 + r*h*M, M);
    cov("N", M, 2*r*h, X1, CCd);
    lacpy("All", r*h, r*h, &CCd[2*r*h * r*h], 2*r*h, CC21, r*h);
    d4 = relabsdiff(CC, CC21, r*h * r*h);
    cov("N", M, 2*r*h, X2, CCd);
    lacpy("All", r*h, r*h, &CCd[2*r*h * r*h], 2*r*h, CC21, r*h);
    d5 = relabsdiff(CC, CC21, r*h * r*h);
    dmax = max(max(d4,d5), dmax);
    freem(CC21);
    freem(CCd); freem(X2); freem(X1); freem(eps); freem(X); // keep SS and CC
    //
    // CHECK STARTING FROM GIVEN X'S (ONE AND TWO STEP FORECASTS):
    allocate(X0, r*h);
    allocate(X, r*(h+2)*M);
    allocate(X1, r*M);
    allocate(X2, r*M);
    for (i=0; i<r; i++) X0[i] = 3.0 + i;
    for (i=1; i<h; i++) copy(r, X0, 1, X0 + i*r, 1);
    varmapack_sim(A, B, Sig, mu, p, q, r, h+2, M, X0, rng, X, 0, &OK); xAssert(OK);
    lacpy("All", r, M, &X[r*h], r*(h+2), X1, r);
    lacpy("All", r, M, &X[r*(h+1)], r*(h+2), X2, r);
    allocate(Ex1, r);
    allocate(Ex2, r);
    allocate(Vx1, r*r);
    expX(A, B, X, mu, CC, SS, Sig, p, q, r, h, Ex1, Ex2, Vx1);
    allocate(mud, r);
    meanmat("T", r, M, X1, r, mud); d6 = relabsdiff(Ex1, mud, r);
    meanmat("T", r, M, X2, r, mud); d7 = relabsdiff(Ex2, mud, r);
    allocate(SSd, r*r);
    cov("T", r, M, X1, SSd);
    d8 = relabsdiff(Vx1, SSd, r*r);
    freem(mud); freem(X2); freem(X1); freem(X); freem(X0);
    freem(SSd); freem(Vx1); freem(Ex2); freem(Ex1);
    freem(SS); freem(CC);
    //
    // PRINT SUMMARY IF REQUESTED, OR IF MAX DIFFERENCE IS TOO BIG:
    dmax = max(max(max(d6,d7),d8), dmax);
    ifail |= dmax > 0.035;
    if ((PRINT && FULL) || dmax > 0.035) {      
      printf("\n");
      if (dmax > 0.035) printf("MAX DIFFERENCE TOO HIGH IN ");
      printf("TESTCASE %s\n", testname);
      printf("  Difference between theoretical and data mean       = %.1f%%\n", d1*100);
      printf("  Long series, covariance difference at lags 0 and 1 = %.1f%%\n", d2*100);
      printf("  Several short series, whole series covariance diff = %.1f%%\n", d3*100);
      printf("  Cov(x,eps) difference, first half of series        = %.1f%%\n", d4*100);
      printf("  Cov(x,eps) difference, second half of series       = %.1f%%\n", d5*100);
      printf("  Start from given x's, one-step forecast difference = %.1f%%\n", d6*100);
      printf("  Start from given x's, two step forecast difference = %.1f%%\n", d7*100);
      printf("  Variance difference of one-step forecast           = %.1f%%\n", d8*100);
      fflush(0);
    }
    else if (PRINT) {
      printf(".");
      fflush(0);
    }
    freem(mu); freem(Sig); freem(B); freem(A);
    icase++;
    //break;
  }
  rand_freem(rng);
  return ifail;
}

static void expX(double A[], double B[], double X[], double mu[], double CC[],
                 double SS[], double Sig[], int p, int q, int r, int n,
                 double Ex1[], double Ex2[], double Vx1[]) {
  // Calculate one and two step expected forecast and one step forecast variance.
  int i, info;
  double *Xm, *SSx, *L, *Eeps, *BB=0, *EE=0, *LC=0, *EB=0, *CCq;
  allocate(Xm, r*n);
  copy(r*n, X, 1, Xm, 1); // Xm contains X - mu
  for (i=0; i<n; i++) axpy(r, -1.0, mu, 1, Xm + i*r, 1);
  setzero(r, Ex1);
  setzero(r, Ex2);
  for (i=0; i<p; i++) // Forecast one step
    gemv("N", r, r, 1.0, A + i*r*r, r, Xm + (n-i-1)*r, 1, 1.0, Ex1, 1);
  allocate(L, r*n*r*n);
  copy(r*n*r*n, SS, 1, L, 1);
  potrf("Lo", r*n, L, r*n, &info);
  allocate(SSx, r*n);
  copy(r*n, Xm, 1, SSx, 1);
  trsv("Lo", "NT", "Nudia", r*n, L, r*n, SSx, 1);
  trsv("Lo", "T", "Nudia", r*n, L, r*n, SSx, 1);  // SS\x
  allocate(Eeps, r*n); // set Eeps to E(eps|x) (expected eps value given x)
  gemv("T", r*n, r*n, 1.0, CC, r*n, SSx, 1, 1.0, Eeps, 1); // C'*(SS\x)  
  freem(SSx);
  setzero(r*r, Vx1);
  copy(r*r, Sig, 1, Vx1, 1);
  if (q) {
    allocate(BB, r*r*q);
    allocate(EE, r*q*r*q);
    for (i=0; i<q; i++) {
      gemv("N", r, r, 1.0, B + i*r*r, r, Eeps + (n-i-1)*r, 1, 1.0, Ex1, 1);
      copy(r*r, B + i*r*r, 1, BB + (q-i-1)*r*r, 1);
      lacpy("All", r, r, Sig, r, EE + i*r*r*q + i*r, r*q);
    }
    CCq = CC + (n-q)*r*r*n;       // CCq = last q block columns of CC
    allocate(LC, r*q*r*n);        // First copy CCq to LC
    copy(r*q*r*n, CCq, 1, LC, 1); // Set LC to LS\CCq
    trsm("Left", "Lo", "NT", "Nudia", r*n, r*q, 1.0, L, r*n, LC, r*n);
    syrk("Lo", "T", r*q, r*n, -1.0, LC, r*n, 1.0, EE, r*q);// EE := EE - CCq'*(SS\CCq)
    copylowertoupper(r*q, EE, r*q);
    allocate(EB, r*r*q);
    gemm("N", "T", r*q, r, r*q, 1.0, EE, r*q, BB, r, 1.0, EB, r*q);
    gemm("N", "N", r, r, r*q, 1.0, BB, r, EB, r*q, 1.0, Vx1, r);
  }
  for (i=0; i<p; i++) { // Forecast two steps
    if (i==0) gemv("N", r, r, 1.0, A, r, Ex1, 1, 1.0, Ex2, 1);
    else gemv("N", r, r, 1.0, A + i*r*r, r, Xm + (n-i)*r, 1, 1.0, Ex2, 1);
  }
  if (q) {
    for (i=1; i<q; i++) {
      gemv("N", r, r, 1.0, B + i*r*r, r, Eeps + (n-i)*r, 1, 1.0, Ex2, 1);
    }
    freem(EB); freem(LC); freem(EE); freem(BB);
  }
  axpy(r, 1.0, mu, 1, Ex1, 1);
  axpy(r, 1.0, mu, 1, Ex2, 1);
  freem(Eeps); freem(L); freem(Xm);
}
