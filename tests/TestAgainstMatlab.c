// TestCompareWithMatlab.c
#include "VarmaUtilities.h"
#include "ExtraUtil.h"
#include "allocate.h"
#include "error.h"
#include "xCheck.h"
#include "printX.h"
#include "Tests.h"

#include "varmapack.h"
#include "varmapack.h"
#include "DebugUtil.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Requires an include file generated by matlabcompare.m defining:
//   ncase, p[], q[], r[], n[], and pointer arrays A[], B[], Sig[], X[].
// ---------------------------------------------------------------------------
static void startmat(double *x0, int r, int h);

void TestAgainstMatlab(void) {
  // Bring in MATLAB reference data
#include "matlabcompare.inc"
  int ncases = sizeof(cases)/sizeof(cases[0]);
  for (int k = 0; k < ncases; k++) {
    int icase = cases[k];
    int pk, qk, rk, h;

    // Set additional message to testcase number
    printI("TESTCASE NUMBER", icase);
    char addmsg[32] = "varmapack_testcase number **";
    if (icase < 100) snprintf(addmsg, 32, "varmapack_testcase number %2d", icase);
    xCheckAddMsg(addmsg);

    // Query testcase dimensions and check them
    char name[64] = {0};
    bool ok = varmapack_testcase(0, 0, 0, name, &pk, &qk, &rk, &icase, 0, stderr);
    xCheck(ok);
    xCheck(pk == p[k]);
    xCheck(qk == q[k]);
    xCheck(rk == r[k]);

    // Allocate and fetch actual testcase coefficients
    int r2 = rk*rk, nk = n[k];
    int nA = pk > 0 ? r2*pk : 1;
    int nB = qk > 0 ? r2*qk : 1;
    double *Ak, *Bk, *Sigk;
    allocate(Ak, nA);
    allocate(Bk, nB);
    allocate(Sigk, r2);
    ok = varmapack_testcase(Ak, Bk, Sigk, name, &pk, &qk, &rk, &icase, 0, stderr);
    xCheck(ok);

    // Compare A, B, Sig against MATLAB reference
    xCheck(almostEqual(Ak, A[k], nA));
    xCheck(almostEqual(Bk, B[k], nB));
    xCheck(almostEqual(Sigk, Sig[k], r2));

    // Simulate with varmapack_sim and compare the simulated series with Matlab's
    double *mu = 0, *x0, *Xsim, *Esim, diffE, diffX, tol = 5e-16;
    double *XXsim, *EEsim, *X0sim, *E0sim;
    bool sim_ok;
    h = imax(pk, qk);
    
    allocate(Xsim, rk*nk);
    allocate(XXsim, rk*nk*2);
    allocate(X0sim, rk*nk);
    allocate(Esim,  rk*nk);
    allocate(EEsim,  rk*nk*2);
    allocate(E0sim,  rk*nk);
    allocate(x0, rk*h);
    startmat(x0, rk, h);
    randompack_rng *rng = randompack_create("PM", 42);
    printM("Ak", Ak, rk, rk*pk);
    printM("Bk", Bk, rk, rk*qk);
    printM("Sigk", Sigk, rk, rk);
    varmapack_sim(Ak, Bk, Sigk, mu, pk, qk, rk, nk, 1, 0, 0, rng, Xsim, Esim, &sim_ok);
    varmapack_sim(Ak, Bk, Sigk, mu, pk, qk, rk, nk, 2, 0, 0, rng, XXsim, EEsim, &sim_ok);
    varmapack_sim(Ak, Bk, Sigk, mu, pk, qk, rk, nk, 1, x0, h, rng, X0sim, E0sim, &sim_ok);
    printM("Xsim", Xsim, rk, nk);
    xCheck(sim_ok == 1);
    // Compare E and X
    diffE = relabsdiff(Esim, E[k], rk*nk);
    diffX = relabsdiff(Xsim, X[k], rk*nk);
    printSetFmtChar('E');
    printD(">>> diffE", diffE);
    printD(">>> diffX", diffX);
    printD(">>> tolerance", tol*condR[k]);
    printSetFmtChar('f');
    xCheck(diffE < tol*condR[k]);
    xCheck(diffX < tol*condR[k]);
    xCheck(relabsdiff(EEsim, EE[k], rk*nk*2) < tol*condR[k]);
    xCheck(relabsdiff(XXsim, XX[k], rk*nk*2) < tol*condR[k]);
    xCheck(relabsdiff(E0sim, E0[k], rk*nk*2) < tol*condR[k]);
    xCheck(relabsdiff(X0sim, X0[k], rk*nk*2) < tol*condR[k]);

    // Free memory
    freem(Ak);
    freem(Bk);
    freem(Sigk);
    freem(Xsim);
    freem(Esim);
    randompack_free(rng);
  }
  xCheckAddMsg("");
}

static void startmat(double *x0, int r, int h) {
  // Fill r by h matrix with pattern [-2,-1,0,1,2,-2,-1,0,...]
  int vals[] = {-2, -1, 0, 1, 2};
  int n = r*h;
  for (int i=0; i<n; i++) {
    x0[i] = (double)vals[i%5];
  }
}
